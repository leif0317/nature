<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 直流導線磁場模擬 (修正版)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #1a1a1a; touch-action: none; }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
            max-width: 250px;
            font-size: 14px;
            border-left: 5px solid #ff0000; /* 紅色標記提示 */
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            width: 90%;
            justify-content: center;
            pointer-events: auto;
        }

        button {
            padding: 12px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            background-color: #e63946; /* 改用紅色系按鈕 */
            color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            flex: 1;
            max-width: 160px;
            font-weight: bold;
        }
        button:active { transform: scale(0.95); }
        button.secondary { background-color: #457b9d; } /* 藍色系按鈕 */
        
        .mobile-hint {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
            line-height: 1.5;
        }
        strong { color: #ff4d4d; }
    </style>
</head>
<body>

    <div id="info">
        <h3>直流導線磁效應</h3>
        <div><strong>紅色(N)</strong> 指向磁場方向</div>
        <div class="mobile-hint">
            • 單指拖曳背景：旋轉視角<br>
            • 雙指開合：縮放遠近<br>
            • <strong>按住磁針拖曳</strong>：移動位置
        </div>
    </div>

    <div id="controls">
        <button id="toggleCurrentBtn">切換電流 (上)</button>
        <button id="addCompassBtn" class="secondary">＋ 加磁針</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- 全域變數 ---
        let scene, camera, renderer, controls;
        let wire, wireTexture;
        let currentDirection = 1; // 1: Up, -1: Down
        let compasses = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let dragPlane; 
        let isDragging = false;
        let selectedCompass = null;

        // --- 初始化 ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // 相機
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(12, 10, 12);
            camera.lookAt(0, 0, 0);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 燈光
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            scene.add(dirLight);

            // 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // 網格
            const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x333333);
            scene.add(gridHelper);

            // 建立物件
            createAnimatedWire();
            createFieldLines();
            createDragPlane();

            // 預設放置磁針
            addCompass(4, 0);
            addCompass(-2, 3);
            addCompass(0, -5);

            // --- 事件監聽 ---
            window.addEventListener('resize', onWindowResize);
            
            const canvas = renderer.domElement;
            // 整合滑鼠與觸控事件
            canvas.addEventListener('mousedown', onPointerDown);
            canvas.addEventListener('touchstart', onPointerDown, { passive: false });
            
            window.addEventListener('mousemove', onPointerMove);
            window.addEventListener('touchmove', onPointerMove, { passive: false });
            
            window.addEventListener('mouseup', onPointerUp);
            window.addEventListener('touchend', onPointerUp);

            document.getElementById('toggleCurrentBtn').addEventListener('click', toggleCurrent);
            document.getElementById('addCompassBtn').addEventListener('click', () => {
                const r = 3 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                addCompass(r * Math.cos(theta), r * Math.sin(theta));
            });

            animate();
        }

        // --- 產生電流紋理 (黃色箭頭) ---
        function createFlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // 導線底色
            ctx.fillStyle = '#555555';
            ctx.fillRect(0, 0, 64, 128);

            // 繪製箭頭 (亮黃色)
            ctx.fillStyle = '#FFDD00';
            ctx.beginPath();
            // 畫一個向上的箭頭
            ctx.moveTo(32, 20);
            ctx.lineTo(54, 50);
            ctx.lineTo(40, 50);
            ctx.lineTo(40, 100);
            ctx.lineTo(24, 100);
            ctx.lineTo(24, 50);
            ctx.lineTo(10, 50);
            ctx.closePath();
            ctx.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 8); // 導線上重複 8 次
            return texture;
        }

        function createAnimatedWire() {
            wireTexture = createFlowTexture();
            const material = new THREE.MeshPhongMaterial({ 
                map: wireTexture,
                shininess: 60
            });
            const geometry = new THREE.CylinderGeometry(0.3, 0.3, 40, 32);
            wire = new THREE.Mesh(geometry, material);
            scene.add(wire);
        }

        function createFieldLines() {
            // 磁力線 (同心圓)
            const radii = [2, 4, 6, 8, 10];
            const material = new THREE.LineBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.15 });

            radii.forEach(r => {
                const points = [];
                for (let i = 0; i <= 64; i++) {
                    const theta = (i / 64) * Math.PI * 2;
                    points.push(new THREE.Vector3(Math.cos(theta) * r, 0, Math.sin(theta) * r));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                scene.add(new THREE.Line(geometry, material));
            });
        }

        function createDragPlane() {
            const planeGeom = new THREE.PlaneGeometry(100, 100);
            dragPlane = new THREE.Mesh(planeGeom, new THREE.MeshBasicMaterial({ visible: false }));
            dragPlane.rotation.x = -Math.PI / 2;
            scene.add(dragPlane);
        }

        // --- 磁針類別 ---
        class Compass {
            constructor(x, z) {
                this.mesh = new THREE.Group();
                
                // 磁針幾何
                const coneGeom = new THREE.ConeGeometry(0.35, 1.5, 16);
                
                // === 修正：紅色在前方 ===
                
                // N極 (紅色, 指向前方)
                const nMat = new THREE.MeshPhongMaterial({ color: 0xff0000 }); 
                const nPole = new THREE.Mesh(coneGeom, nMat);
                nPole.position.y = 0.75; 
                nPole.rotation.x = -Math.PI / 2; // 讓圓錐尖端指向 Group 的 +Z
                
                // S極 (藍色, 指向後方)
                const sMat = new THREE.MeshPhongMaterial({ color: 0x0066ff }); 
                const sPole = new THREE.Mesh(coneGeom, sMat);
                sPole.position.y = -0.75;
                sPole.rotation.x = Math.PI / 2; // 讓圓錐尖端指向 Group 的 -Z

                this.mesh.add(nPole);
                this.mesh.add(sPole);
                
                // 隱形碰撞盒 (加大點擊範圍)
                const hitBox = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 8, 8),
                    new THREE.MeshBasicMaterial({ visible: false })
                );
                this.mesh.add(hitBox);
                this.hitBox = hitBox;

                this.mesh.position.set(x, 0, z);
                scene.add(this.mesh);
                this.updateRotation();
            }

            updateRotation() {
                const pos = this.mesh.position;
                
                // 電流向量 I (上或下)
                const I = new THREE.Vector3(0, currentDirection, 0);
                
                // 位置向量 R (從導線中心指向磁針)
                const R = new THREE.Vector3(pos.x, 0, pos.z);
                
                // 磁場方向 B = I x R (右手定則)
                const B = new THREE.Vector3();
                B.crossVectors(I, R).normalize();

                // 讓 Group 的前方 (+Z) 看向 (目前位置 + 磁場向量)
                // 這樣 "紅色 N 極" (位於 Group 的 +Z 端) 就會指向磁場方向
                const target = pos.clone().add(B);
                this.mesh.lookAt(target);
            }
        }

        function addCompass(x, z) {
            compasses.push(new Compass(x, z));
        }

        function toggleCurrent() {
            currentDirection *= -1;
            const btn = document.getElementById('toggleCurrentBtn');
            btn.innerText = `切換電流 (${currentDirection === 1 ? '上' : '下'})`;
            compasses.forEach(c => c.updateRotation());
        }

        // --- 觸控/滑鼠 邏輯 ---
        function getPointerPos(event) {
            let cx, cy;
            if (event.changedTouches) {
                cx = event.changedTouches[0].clientX;
                cy = event.changedTouches[0].clientY;
            } else {
                cx = event.clientX;
                cy = event.clientY;
            }
            return {
                x: (cx / window.innerWidth) * 2 - 1,
                y: -(cy / window.innerHeight) * 2 + 1
            };
        }

        function onPointerDown(event) {
            if (event.touches && event.touches.length > 1) return; // 忽略多點觸控

            const coords = getPointerPos(event);
            mouse.set(coords.x, coords.y);
            raycaster.setFromCamera(mouse, camera);

            const hitBoxes = compasses.map(c => c.hitBox);
            const intersects = raycaster.intersectObjects(hitBoxes);

            if (intersects.length > 0) {
                event.preventDefault(); 
                isDragging = true;
                controls.enabled = false; 
                const hitObj = intersects[0].object;
                selectedCompass = compasses.find(c => c.hitBox === hitObj);
            }
        }

        function onPointerMove(event) {
            if (!isDragging || !selectedCompass) return;
            event.preventDefault();

            const coords = getPointerPos(event);
            mouse.set(coords.x, coords.y);
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObject(dragPlane);
            if (intersects.length > 0) {
                const p = intersects[0].point;
                // 防止磁針穿進導線裡
                if (Math.sqrt(p.x**2 + p.z**2) > 0.6) {
                    selectedCompass.mesh.position.set(p.x, 0, p.z);
                    selectedCompass.updateRotation();
                }
            }
        }

        function onPointerUp() {
            isDragging = false;
            selectedCompass = null;
            controls.enabled = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 動畫迴圈 ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 電流動畫
            if (wireTexture) {
                // 減去 offset 代表紋理向上移動 (視覺上電流向上)
                // 乘上 currentDirection: 如果是 -1 (向下)，變成加 offset，紋理向下流
                wireTexture.offset.y -= 0.015 * currentDirection; 
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
