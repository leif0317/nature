<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>åœ°æœˆæ—¥ç³»çµ± - è»Œé“é¢èˆ‡è¦–è¦ºå„ªåŒ–ç‰ˆ</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: 'å¾®è»Ÿæ­£é»‘é«”', 'Segoe UI', sans-serif; }
        
        /* å·¦ä¸‹è§’åœ–ä¾‹ */
        #legend-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 20px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(10, 15, 30, 0.85);
            padding: 12px 25px;
            border-radius: 50px;
            border: 1px solid rgba(150, 150, 150, 0.3);
            backdrop-filter: blur(8px);
            pointer-events: none;
            user-select: none;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.5);
            z-index: 10;
            white-space: nowrap;
        }
        .legend-title { font-weight: bold; color: #fff; margin-right: 10px; padding-right: 15px; border-right: 1px solid rgba(255,255,255,0.3); }
        .legend-item { display: flex; align-items: center; font-size: 13px; }
        .icon { width: 20px; height: 3px; margin-right: 8px; display: inline-block; }
        .icon-circle { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; }
        
        /* å³ä¸‹è§’ç½²å */
        #signature {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 24px;
            font-weight: 900;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 100, 255, 0.8);
            pointer-events: none;
            user-select: none;
            z-index: 20;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
        }

        .lil-gui.root { top: 20px !important; left: 20px !important; right: auto !important; }
    </style>
</head>
<body>

<div id="signature">å°ç²˜è£½ä½œ</div>

<div id="legend-panel">
    <div class="legend-title">åœ–ä¾‹</div>
    
    <div class="legend-item"><span class="icon" style="background: #ff0000; height: 3px;"></span>èµ¤é“(0Â°)</div>
    <div class="legend-item"><span class="icon" style="border-top: 2px dashed #ffff00; background: transparent;"></span>å›æ­¸ç·š(Â±23.5Â°)</div>
    <div class="legend-item"><span class="icon" style="background: #ffff00; height: 3px;"></span>é»ƒé“è»Œè·¡</div>
    <div class="legend-item"><span class="icon" style="border-top: 2px solid #ffffff; background: transparent;"></span>æœˆçƒè»Œé“</div>
    
    <div class="legend-item" style="color:#aaa; font-size:12px; margin-left:5px;">
        (å¤¾è§’: é»ƒé“5.14Â° / èµ¤é“28.64Â°)
    </div>

    <div class="legend-item" style="margin-left: 10px;"><span class="icon-circle" style="background: #00ff00;"></span>è‡ªè½‰(é€†)</div>
    <div class="legend-item"><span class="icon-circle" style="background: #ffff00;"></span>ç›´å°„å…‰</div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'lil-gui';

    // å…¨åŸŸè®Šæ•¸
    let earthMesh, axisLine, arrowGroup, sunArrow;
    let markersGroup;
    let eclipticPlane, moonPlane; // æ–°å¢è»Œé“é¢è®Šæ•¸
    
    // 1. åˆå§‹åŒ–
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 20000);
    const initialCameraPos = { x: 0, y: 300, z: 500 };
    camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.NoToneMapping; 
    document.body.appendChild(renderer.domElement);

    // ==========================================
    // 2. 70/20/10 æ¯”ä¾‹ç´‹ç†ç”¢ç”Ÿå™¨ (è—è‰²ä¸»å°)
    // ==========================================
    function generateProportionalTexture() {
        const size = 1024;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size / 2;
        const ctx = canvas.getContext('2d');

        // A. è—è‰²æµ·æ´‹ (100% åŸºåº•)
        ctx.fillStyle = "#0055bb";
        ctx.fillRect(0, 0, size, size / 2);

        // B. ç¶ è‰²é™¸åœ° (ç´„ 20% æ•£ä½ˆ)
        ctx.fillStyle = "#00cc44";
        for (let i = 0; i < 60; i++) {
            const x = Math.random() * size;
            const y = Math.random() * (size / 2);
            const radius = Math.random() * 30 + 15;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // C. ç™½è‰²é›²å±¤ (ç´„ 10% é»ç¶´)
        ctx.fillStyle = "#ffffff";
        for (let i = 0; i < 40; i++) {
            const x = Math.random() * size;
            const y = Math.random() * (size / 2);
            const rx = Math.random() * 60 + 20;
            const ry = Math.random() * 25 + 10;
            ctx.beginPath();
            ctx.ellipse(x, y, rx, ry, Math.random() * Math.PI, 0, Math.PI * 2);
            ctx.fill();
        }
        return new THREE.CanvasTexture(canvas);
    }
    const proportionalTexture = generateProportionalTexture();
    const loader = new THREE.TextureLoader();

    // 3. ç’°å¢ƒèˆ‡ç‡ˆå…‰
    scene.add(new THREE.AmbientLight(0xffffff, 0.6)); 
    
    const sunLight = new THREE.PointLight(0xffffff, 2.0, 0);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(2048, 2048);
    scene.add(sunLight);

    // æ˜Ÿç©º
    const starTex = loader.load(
        'https://unpkg.com/three-globe/example/img/night-sky.png',
        undefined, undefined, () => {}
    );
    const starMesh = new THREE.Mesh(
        new THREE.SphereGeometry(4000, 64, 64),
        new THREE.MeshBasicMaterial({ map: starTex, side: THREE.BackSide, color: 0x555555 })
    );
    scene.add(starMesh);

    // 4. å¤ªé™½èˆ‡è»Œé“
    const sunMesh = new THREE.Mesh(
        new THREE.SphereGeometry(15, 64, 64),
        new THREE.MeshBasicMaterial({ color: 0xffcc00, toneMapped: false, transparent: true, opacity: 0.95 })
    );
    const sunGlow = new THREE.Mesh(
        new THREE.SphereGeometry(18, 64, 64),
        new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.3 })
    );
    scene.add(sunMesh, sunGlow);

    const orbitRadius = 150;

    // --- ã€ä¿®æ”¹ã€‘åœ°çƒè»Œè·¡ï¼šè®Šç²—ã€è®Šé»ƒ ---
    // ç‚ºäº†è®“ç·šæ¢è®Šç²—ï¼Œæ”¹ç”¨ TubeGeometry (ç®¡ç‹€å¹¾ä½•é«”)
    class OrbitCurve extends THREE.Curve {
        constructor(scale) { super(); this.scale = scale; }
        getPoint(t) {
            const tx = Math.cos(2 * Math.PI * t) * this.scale;
            const tz = Math.sin(2 * Math.PI * t) * this.scale;
            return new THREE.Vector3(tx, 0, tz);
        }
    }
    const orbitPath = new OrbitCurve(orbitRadius);
    const orbitGeometry = new THREE.TubeGeometry(orbitPath, 200, 1.2, 8, true); // åŠå¾‘1.2ï¼Œç´„ç­‰æ–¼3å€ç²—ç´°
    const orbitLine = new THREE.Mesh(
        orbitGeometry,
        new THREE.MeshBasicMaterial({ color: 0xffff00 }) // é»ƒè‰²
    );
    scene.add(orbitLine);

    // --- ã€æ–°å¢ã€‘é»ƒé“é¢ (æ·ºé»ƒè‰²åœ“ç›¤) ---
    eclipticPlane = new THREE.Mesh(
        new THREE.CircleGeometry(orbitRadius + 60, 64), // æ¯”è»Œé“ç¨å¤§
        new THREE.MeshBasicMaterial({ 
            color: 0xffffaa, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.15, // æ·ºæ·ºçš„é€æ˜
            depthWrite: false // é¿å…é®æ“‹èƒŒæ™¯æ˜Ÿæ˜Ÿ
        })
    );
    eclipticPlane.rotation.x = Math.PI / 2; // æ”¾å¹³
    eclipticPlane.visible = false; // é è¨­é—œé–‰
    scene.add(eclipticPlane);


    // --- ç¯€æ°£æ¨™è¨˜ ---
    markersGroup = new THREE.Group();
    scene.add(markersGroup);

    function createTextSprite(text, color) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 128;
        ctx.fillStyle = color;
        ctx.font = 'bold 40px "Microsoft JhengHei", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = "rgba(0,0,0,1.0)";
        ctx.shadowBlur = 4;
        ctx.fillText(text, 128, 64);
        const texture = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false }));
        sprite.scale.set(40, 20, 1);
        return sprite;
    }
    
    // æ¨™ç±¤è²¼è¿‘è»Œé“
    const labelDist = orbitRadius + 25; 

    // å†¬è‡³ (å³, +X)
    const winterLabel = createTextSprite('å†¬è‡³', '#44aaff');
    winterLabel.position.set(labelDist, 0, 0);
    markersGroup.add(winterLabel);

    // æ˜¥åˆ† (å¾Œ, -Z)
    const springLabel = createTextSprite('æ˜¥åˆ†', '#55ff55');
    springLabel.position.set(0, 0, -labelDist);
    markersGroup.add(springLabel);

    // å¤è‡³ (å·¦, -X)
    const summerLabel = createTextSprite('å¤è‡³', '#ff4444');
    summerLabel.position.set(-labelDist, 0, 0);
    markersGroup.add(summerLabel);

    // ç§‹åˆ† (å‰, +Z)
    const autumnLabel = createTextSprite('ç§‹åˆ†', '#ffaa55');
    autumnLabel.position.set(0, 0, labelDist);
    markersGroup.add(autumnLabel);

    // 5. åœ°çƒç³»çµ±
    const earthPosGroup = new THREE.Group();
    scene.add(earthPosGroup);

    // åœ°è»¸å‚¾æ–œ (-23.5)
    const earthTiltGroup = new THREE.Group();
    earthTiltGroup.rotation.z = THREE.MathUtils.degToRad(-23.5); 
    earthPosGroup.add(earthTiltGroup);

    // åœ°çƒ (æ‰‹ç¹ªç´‹ç† + ç´”ç™½æè³ª)
    earthMesh = new THREE.Mesh(
        new THREE.SphereGeometry(7, 64, 64),
        new THREE.MeshBasicMaterial({
            map: proportionalTexture,
            color: 0xffffff 
        })
    );
    earthTiltGroup.add(earthMesh);

    // åœ°è»¸ç·š
    axisLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, -15, 0), new THREE.Vector3(0, 15, 0)]),
        new THREE.LineBasicMaterial({ color: 0xaaaaaa })
    );
    earthTiltGroup.add(axisLine);

    // åŸºæº–ç·š
    function createLatLine(lat, color, dashed) {
        const rad = THREE.MathUtils.degToRad(lat);
        const r = 7.07 * Math.cos(rad); const y = 7.07 * Math.sin(rad);
        const geo = new THREE.BufferGeometry().setFromPoints(new THREE.EllipseCurve(0, 0, r, r).getPoints(128));
        const mat = dashed ? 
            new THREE.LineDashedMaterial({ color, dashSize: 0.5, gapSize: 0.3, scale: 1, linewidth: 2 }) : 
            new THREE.LineBasicMaterial({ color, linewidth: 2 });
        const line = dashed ? new THREE.Line(geo, mat) : new THREE.LineLoop(geo, mat);
        if (dashed) line.computeLineDistances();
        line.rotation.x = -Math.PI / 2; line.position.y = y;
        return line;
    }
    earthMesh.add(createLatLine(0, 0xff0000, false)); 
    earthMesh.add(createLatLine(23.5, 0xffff00, true)); 
    earthMesh.add(createLatLine(-23.5, 0xffff00, true)); 

    // è‡ªè½‰ç®­é ­
    arrowGroup = new THREE.Group();
    arrowGroup.position.set(0, 11, 0); 
    earthTiltGroup.add(arrowGroup);
    const arcMesh = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.25, 16, 64, Math.PI * 1.5), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
    arcMesh.rotation.x = Math.PI / 2; arcMesh.rotation.z = Math.PI * 0.75; arrowGroup.add(arcMesh);
    const cone = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.8, 32), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
    cone.position.set(-2.47, 0, 2.47); cone.rotation.x = Math.PI / 2; cone.rotation.z = Math.PI * 0.25; arrowGroup.add(cone);

    // 6. æœˆçƒç³»çµ±
    const moonSystemContainer = new THREE.Group();
    earthPosGroup.add(moonSystemContainer);
    moonSystemContainer.rotation.z = THREE.MathUtils.degToRad(5.14);

    const moonDist = 32;
    const moonOrbitLine = new THREE.LineLoop(
        new THREE.BufferGeometry().setFromPoints(new THREE.EllipseCurve(0, 0, moonDist, moonDist).getPoints(128)),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
    );
    moonOrbitLine.rotation.x = Math.PI / 2;
    moonSystemContainer.add(moonOrbitLine);

    // --- ã€æ–°å¢ã€‘ç™½é“é¢ (æ·ºç™½è‰²åœ“ç›¤) ---
    // æ›è¼‰åœ¨ moonSystemContainer ä¸‹ï¼Œé€™æ¨£å®ƒæœƒè‡ªå‹•è·Ÿè‘—æœ‰ 5.14 åº¦çš„å‚¾è§’
    moonPlane = new THREE.Mesh(
        new THREE.CircleGeometry(moonDist + 10, 64),
        new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.15, 
            depthWrite: false 
        })
    );
    moonPlane.rotation.x = Math.PI / 2; // ç›¸å°æ–¼å®¹å™¨æ”¾å¹³
    moonPlane.visible = false; // é è¨­é—œé–‰
    moonSystemContainer.add(moonPlane);

    const moonRotator = new THREE.Group();
    moonSystemContainer.add(moonRotator);
    const moonMesh = new THREE.Mesh(
        new THREE.SphereGeometry(2, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xffffff }) 
    );
    moonMesh.position.set(moonDist, 0, 0);
    moonRotator.add(moonMesh);

    // 7. å¤ªé™½ç›´å°„ç®­é ­
    sunArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1, 0xffff00, 8, 5);
    scene.add(sunArrow);

    // 8. æ§åˆ¶èˆ‡å‹•ç•«
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.zoomSpeed = 0.3;
    controls.rotateSpeed = 0.5;
    controls.minDistance = 100;
    controls.maxDistance = 1500;
    controls.enablePan = false;

    // --- GUI æ§åˆ¶é¢æ¿ ---
    const gui = new GUI({ title: 'âš™ï¸ æ¨¡æ“¬æ§åˆ¶' });
    const params = { 
        speed: 1.0, 
        pause: false, 
        earthScale: 1.0, 
        showMarkers: true,
        showEcliptic: false, // æ–°å¢
        showMoonPlane: false, // æ–°å¢
        viewZoom: 1.0,
        resetView: function() {
            camera.position.set(initialCameraPos.x, initialCameraPos.y, initialCameraPos.z);
            camera.zoom = 1.0;
            camera.updateProjectionMatrix();
            controls.reset();
            params.viewZoom = 1.0;
        }
    };
    
    gui.add(params, 'earthScale', 0.5, 3.0).name('ğŸŒ åœ°çƒå¤§å°').onChange(v => {
        if (earthMesh) earthMesh.scale.set(v, v, v);
        if (axisLine) axisLine.scale.set(1, v, 1);
        if (arrowGroup) arrowGroup.position.y = 11 + (v - 1) * 7;
    });
    gui.add(params, 'showMarkers').name('é¡¯ç¤ºç¯€æ°£').onChange(v => markersGroup.visible = v);
    
    // ã€æ–°å¢ã€‘è»Œé“é¢æ§åˆ¶é–‹é—œ
    gui.add(params, 'showEcliptic').name('ğŸŸ¨ é¡¯ç¤ºé»ƒé“é¢').onChange(v => eclipticPlane.visible = v);
    gui.add(params, 'showMoonPlane').name('â¬œ é¡¯ç¤ºç™½é“é¢').onChange(v => moonPlane.visible = v);

    gui.add(params, 'speed', 0, 2.5).name('â© é€Ÿåº¦');
    gui.add(params, 'pause').name('â¸ æš«åœ');
    gui.add(params, 'viewZoom', 0.1, 3.0).name('ğŸ” ç•«é¢ç¸®æ”¾').onChange(v => {
        camera.zoom = v;
        camera.updateProjectionMatrix();
    });
    gui.add(params, 'resetView').name('âŸ² é‡ç½®è¦–è§’');

    let orbitAngle = 0;

    function animate() {
        requestAnimationFrame(animate);

        if (!params.pause) {
            const dt = 0.008 * params.speed;
            
            // é€†æ™‚é‡å…¬è½‰
            orbitAngle -= dt * 0.8; 
            
            earthPosGroup.position.x = Math.cos(orbitAngle) * orbitRadius;
            earthPosGroup.position.z = Math.sin(orbitAngle) * orbitRadius;
            
            if (earthMesh) earthMesh.rotation.y += dt * 15;
            if (arrowGroup) arrowGroup.rotation.y += dt * 15;
            moonRotator.rotation.y += dt * 10;
        }

        const earthPos = earthPosGroup.position.clone();
        const arrowGap = 8 * params.earthScale;
        const dist = earthPos.length() - arrowGap;
        sunArrow.setDirection(earthPos.normalize());
        sunArrow.setLength(dist > 0 ? dist : 0, 8, 5);

        markersGroup.children.forEach(sprite => sprite.lookAt(camera.position));
        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>