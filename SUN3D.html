<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 太陽軌跡 - 小粘製作</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; }
        #gui-container { position: absolute; top: 10px; right: 10px; }
        
        /* 標籤樣式 */
        .label {
            color: #ffffff;
            font-family: sans-serif;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            white-space: nowrap;
        }

        /* 數位時鐘樣式 */
        #clock-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        #time-text {
            font-size: 3rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-family: 'Courier New', Courier, monospace;
            display: block;
        }
        #clock-sub {
            font-size: 1rem;
            color: #ddd;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        /* --- [新增] 顯眼的署名樣式 --- */
        #signature {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5); /* 半透明黑底 */
            border: 1px solid rgba(255, 255, 255, 0.3); /* 淡淡白框 */
            padding: 10px 20px;
            border-radius: 10px;
            color: #ffffff;
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            pointer-events: none; /* 讓滑鼠點擊可以穿透 */
            z-index: 20;
            backdrop-filter: blur(5px); /* 背景模糊效果 (毛玻璃) */
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #signature span {
            color: #FFD700; /* 金色裝飾 */
        }
    </style>
</head>
<body>
    <div id="clock-display">
        <span id="time-text">12:00</span>
        <span id="clock-sub">24小時全日觀測</span>
    </div>

    <div id="signature">
        <span>✦</span> 小粘製作 <span>✦</span>
    </div>

    <div id="gui-container"></div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
        }
      }
    </script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // --- 全域變數 ---
    const SCENE_RADIUS = 50;
    
    const DECLINATIONS = {
        'Summer Solstice (夏至)': 23.5,
        'Equinox (春/秋分)': 0,
        'Winter Solstice (冬至)': -23.5
    };

    let scene, camera, renderer, labelRenderer, controls;
    let sunMesh, sunLight, ambientLight;
    let ncpLine, ncpLabelObj;
    let pathLines = {}; 
    let pathLabels = {};
    
    const timeTextElement = document.getElementById('time-text');

    // GUI 參數
    const params = {
        latitude: 23.5, 
        hour: 12.0,      // 0 - 24
        season: 'Summer Solstice (夏至)',
        shadows: true,
        showDome: true
    };

    init();
    animate();

    function init() {
        // 1. 場景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);

        // 2. 相機
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-30, 40, -60); 
        camera.lookAt(0, 0, 0);

        // 3. 渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // 4. 控制器 (允許轉到地底下)
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI; 

        // 5. 初始化
        setupLights();
        createEnvironment();
        createSun();
        initDynamicObjects();
        createGUI();
        
        updateAll(); 
        window.addEventListener('resize', onWindowResize);
    }

    function setupLights() {
        ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        sunLight = new THREE.PointLight(0xffffff, 1.5, SCENE_RADIUS * 3);
        sunLight.castShadow = true;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = SCENE_RADIUS * 2;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);
    }

    function createSun() {
        const sunGeometry = new THREE.SphereGeometry(SCENE_RADIUS / 20, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sunMesh);
    }

    function createEnvironment() {
        // 地面 (雙面顯示)
        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(SCENE_RADIUS, 64),
            new THREE.MeshStandardMaterial({ 
                color: 0xc2b280, 
                roughness: 1, 
                metalness: 0,
                side: THREE.DoubleSide 
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // 天球網格
        const dome = new THREE.Mesh(
            new THREE.SphereGeometry(SCENE_RADIUS * 0.98, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.15 })
        );
        dome.name = 'SkyDome';
        scene.add(dome);

        // 標竿
        const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, SCENE_RADIUS/5, 16),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        pole.position.y = SCENE_RADIUS/10;
        pole.castShadow = true;
        pole.receiveShadow = true;
        scene.add(pole);

        addLabel('東 (E)', SCENE_RADIUS + 5, 0, 0);
        addLabel('西 (W)', -SCENE_RADIUS - 5, 0, 0);
        addLabel('南 (S)', 0, 0, SCENE_RADIUS + 5);
        addLabel('北 (N)', 0, 0, -SCENE_RADIUS - 5);
        addLabel('天頂', 0, SCENE_RADIUS + 5, 0);
    }

    function initDynamicObjects() {
        const ncpMat = new THREE.LineBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.6 });
        ncpLine = new THREE.Line(new THREE.BufferGeometry(), ncpMat);
        scene.add(ncpLine);
        ncpLabelObj = addLabel('北極 (NCP)', 0, 0, 0);

        for (const seasonName in DECLINATIONS) {
            const mat = new THREE.LineBasicMaterial({ 
                color: seasonName.includes('Summer') ? 0xff4500 : (seasonName.includes('Winter') ? 0x00bfff : 0xffff00),
                transparent: true, opacity: 0.5
            });
            const line = new THREE.Line(new THREE.BufferGeometry(), mat);
            scene.add(line);
            pathLines[seasonName] = line;
            pathLabels[seasonName] = addLabel(seasonName.split(' ')[0], 0, 0, 0);
        }
    }

    function addLabel(text, x, y, z) {
        const div = document.createElement('div');
        div.className = 'label';
        div.textContent = text;
        const label = new CSS2DObject(div);
        label.position.set(x, y, z);
        scene.add(label);
        return label;
    }

    function getSunPositionVector(hour, declinationDeg, latitudeDeg) {
        const latRad = THREE.MathUtils.degToRad(latitudeDeg);
        const decRad = THREE.MathUtils.degToRad(declinationDeg);
        
        const offsetFromNoon = hour - 12;
        const hourAngle = offsetFromNoon * (Math.PI / 12); 

        const x_eq = -SCENE_RADIUS * Math.cos(decRad) * Math.sin(hourAngle);
        const y_eq = SCENE_RADIUS * Math.sin(decRad);
        const z_eq = SCENE_RADIUS * Math.cos(decRad) * Math.cos(hourAngle);
        
        const x_final = x_eq;
        const y_final = y_eq * Math.sin(latRad) + z_eq * Math.cos(latRad);
        const z_final = -y_eq * Math.cos(latRad) + z_eq * Math.sin(latRad);

        return new THREE.Vector3(x_final, y_final, z_final);
    }

    function updateAll() {
        const currentDec = DECLINATIONS[params.season];
        
        const sunPos = getSunPositionVector(params.hour, currentDec, params.latitude);
        sunMesh.position.copy(sunPos);
        sunLight.position.copy(sunPos);
        
        const h = Math.floor(params.hour);
        const m = Math.floor((params.hour - h) * 60);
        timeTextElement.innerText = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;

        // 日夜光影邏輯
        const heightRatio = sunPos.y / SCENE_RADIUS;
        ambientLight.intensity = Math.max(0.02, heightRatio < 0 ? 0.05 : 0.1 + heightRatio * 0.7);
        
        const skyColor = new THREE.Color(0x87CEEB);
        const nightColor = new THREE.Color(0x02020a);
        const sunsetColor = new THREE.Color(0xFF4500);
        const twilightColor = new THREE.Color(0x4b0082);
        
        let finalBgColor;
        if (heightRatio > 0.1) {
            finalBgColor = skyColor.lerp(sunsetColor, 1 - Math.min(1, heightRatio * 3));
        } else if (heightRatio > -0.1) {
            const t = (0.1 - heightRatio) / 0.2; 
            finalBgColor = sunsetColor.lerp(twilightColor, t);
        } else {
            const t = Math.min(1, (-0.1 - heightRatio) * 3);
            finalBgColor = twilightColor.lerp(nightColor, t);
        }
        
        scene.background = finalBgColor;
        scene.fog.color = finalBgColor;

        sunLight.castShadow = (heightRatio > -0.05);

        // NCP
        const latRad = THREE.MathUtils.degToRad(params.latitude);
        const ncpY = SCENE_RADIUS * Math.sin(latRad);
        const ncpZ = -SCENE_RADIUS * Math.cos(latRad);
        ncpLine.geometry.setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0, ncpY, ncpZ)]);
        ncpLabelObj.position.set(0, ncpY + 2, ncpZ);

        // 軌跡線 (0-24h)
        for (const [seasonName, dec] of Object.entries(DECLINATIONS)) {
            const points = [];
            for (let h = 0; h <= 24; h += 0.5) {
                const vec = getSunPositionVector(h, dec, params.latitude);
                points.push(vec);
            }
            points.push(getSunPositionVector(0, dec, params.latitude));

            pathLines[seasonName].geometry.setFromPoints(points);
            
            const noonPos = getSunPositionVector(12, dec, params.latitude);
            pathLabels[seasonName].position.set(noonPos.x, noonPos.y + 2, noonPos.z);
            
            const isCurrent = (seasonName === params.season);
            pathLines[seasonName].material.opacity = isCurrent ? 1.0 : 0.1;
            pathLines[seasonName].material.linewidth = isCurrent ? 3 : 1;
        }
    }

    function createGUI() {
        const gui = new GUI({ container: document.getElementById('gui-container') });
        
        gui.add(params, 'latitude', 0, 90).name('緯度 (0-90)').onChange(updateAll);
        gui.add(params, 'season', Object.keys(DECLINATIONS)).name('季節').onChange(updateAll);
        gui.add(params, 'hour', 0, 24, 0.05).name('時間 (0-24)').onChange(updateAll);
        gui.add(params, 'shadows').name('啟用影子').onChange(v => sunLight.castShadow = v);
        gui.add(params, 'showDome').name('顯示天球').onChange(v => scene.getObjectByName('SkyDome').visible = v);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }
</script>
</body>
</html>