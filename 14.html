<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨åŠŸèƒ½ä¸‰è§’å½¢æ¼”ç¤º (ç¸®æ”¾/æ—‹è½‰/æ•¸æ“š/é–å®š)</title>
    <style>
        :root {
            --primary: #2c3e50;
            --accent: #3498db;
            --light: #ecf0f1;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar Layout */
        #sidebar {
            width: 340px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            z-index: 10;
            flex-shrink: 0;
        }

        h3 { margin: 0 0 10px 0; color: var(--primary); font-size: 1.1em; border-bottom: 2px solid var(--accent); padding-bottom: 5px;}

        /* Control Groups */
        .control-section {
            background: #fdfdfd;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.9em;
            cursor: pointer;
        }
        .toggle-row input { margin-right: 8px; transform: scale(1.1); }
        .sub-option { margin-left: 24px; font-size: 0.85em; color: #555; }

        /* Measurement Inputs */
        .measure-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        .measure-row label { width: 45px; font-weight: bold; }
        .measure-row input[type="number"] {
            width: 60px;
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: right;
        }
        .lock-check { margin-left: 5px; cursor: pointer; }
        
        /* Slider Controls */
        .slider-container { margin-bottom: 10px; }
        input[type="range"] { width: 100%; cursor: pointer; margin-top: 5px;}

        /* Colors */
        .c-centroid { color: #e67e22; }
        .c-circum { color: #2980b9; }
        .c-incenter { color: #27ae60; }

        /* Main Canvas */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            background: radial-gradient(circle, #ffffff 0%, #f0f2f5 100%);
            cursor: crosshair;
            overflow: hidden;
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* Real-time Data Panel */
        #data-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            padding: 15px;
            font-size: 0.85em;
            pointer-events: none;
            border-left: 4px solid var(--accent);
        }
        .data-group { margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .data-group:last-child { border-bottom: none; }
        .data-title { font-weight: bold; margin-bottom: 3px; color: #555; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .data-val { font-family: 'Consolas', monospace; font-weight: bold; }

        .hint {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #666;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h3>é¡¯ç¤ºèˆ‡é€£ç·šè¨­å®š</h3>
    <div class="control-section">
        <label class="toggle-row c-centroid">
            <input type="checkbox" id="showCentroid" checked> é‡å¿ƒ (G) / ä¸­ç·š
        </label>
        <label class="toggle-row c-centroid sub-option">
            <input type="checkbox" id="showCentroidLines"> é€£ç·š GA, GB, GC
        </label>
        <hr style="border:0; border-top:1px dashed #eee; margin:5px 0;">

        <label class="toggle-row c-circum">
            <input type="checkbox" id="showCircum" checked> å¤–å¿ƒ (O) / å¤–æ¥åœ“
        </label>
        <label class="toggle-row c-circum sub-option">
            <input type="checkbox" id="showCircumLines"> é€£ç·š OA, OB, OC
        </label>
        <hr style="border:0; border-top:1px dashed #eee; margin:5px 0;">

        <label class="toggle-row c-incenter">
            <input type="checkbox" id="showIncenter" checked> å…§å¿ƒ (I) / å…§åˆ‡åœ“
        </label>
        <label class="toggle-row c-incenter sub-option">
            <input type="checkbox" id="showIncenterLines"> é€£ç·š IA, IB, IC
        </label>
    </div>

    <h3>å¹¾ä½•åƒæ•¸ (è¼¸å…¥/é–å®š)</h3>
    <div class="control-section">
        <div class="measure-row">
            <label>c (AB)</label>
            <input type="number" id="val_c" step="1">
            <input type="checkbox" id="lock_c" class="lock-check" title="é–å®šé•·åº¦"> ğŸ”’
        </div>
        <div class="measure-row">
            <label>a (BC)</label>
            <input type="number" id="val_a" step="1">
            <input type="checkbox" id="lock_a" class="lock-check" title="é–å®šé•·åº¦"> ğŸ”’
        </div>
        <div class="measure-row">
            <label>b (AC)</label>
            <input type="number" id="val_b" step="1">
            <input type="checkbox" id="lock_b" class="lock-check" title="é–å®šé•·åº¦"> ğŸ”’
        </div>

        <div style="font-size:0.8em; color:#666; margin:10px 0 5px 0;">è§’åº¦</div>
        <div class="measure-row">
            <label>âˆ A</label>
            <input type="number" id="val_A" step="0.1"> Â°
        </div>
        <div class="measure-row">
            <label>âˆ B</label>
            <input type="number" id="val_B" step="0.1"> Â°
        </div>
        <div class="measure-row">
            <label>âˆ C</label>
            <input type="number" id="val_C" step="0.1"> Â°
        </div>
    </div>

    <h3>ç•«é¢æ“ä½œ</h3>
    <div class="control-section">
        <div class="slider-container">
            <label>æ—‹è½‰ (Rotate): <span id="rotVal">0</span>Â°</label>
            <input type="range" id="rotationRange" min="0" max="360" value="0">
        </div>
        
        <div class="slider-container">
            <label>ç¸®æ”¾ (Zoom): <span id="zoomVal">1.0</span>x</label>
            <input type="range" id="zoomRange" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>

        <div style="margin-top:10px; text-align:center;">
            <button onclick="resetView()" style="padding:5px 15px; cursor:pointer;">é‡ç½®è¦–è§’èˆ‡ä½ç½®</button>
        </div>
    </div>
</div>

<div id="canvas-container">
    <canvas id="geoCanvas"></canvas>
    
    <div id="data-panel">
        <div class="data-group">
            <div class="data-title">åŸºæœ¬å±¬æ€§</div>
            <div class="data-row"><span>é¢ç©:</span> <span id="data_area" class="data-val">0</span></div>
            <div class="data-row"><span>å‘¨é•·:</span> <span id="data_peri" class="data-val">0</span></div>
        </div>
        <div class="data-group" id="data_group_G" style="display:none; color:#d35400;">
            <div class="data-title">é‡å¿ƒ (G)</div>
            <div class="data-row"><span>GA:</span> <span id="data_ga" class="data-val">0</span></div>
            <div class="data-row"><span>GB:</span> <span id="data_gb" class="data-val">0</span></div>
            <div class="data-row"><span>GC:</span> <span id="data_gc" class="data-val">0</span></div>
        </div>
        <div class="data-group" id="data_group_O" style="display:none; color:#2980b9;">
            <div class="data-title">å¤–å¿ƒ (O)</div>
            <div class="data-row"><span>R (åŠå¾‘):</span> <span id="data_R" class="data-val">0</span></div>
        </div>
        <div class="data-group" id="data_group_I" style="display:none; color:#27ae60;">
            <div class="data-title">å…§å¿ƒ (I)</div>
            <div class="data-row"><span>r (åŠå¾‘):</span> <span id="data_r" class="data-val">0</span></div>
            <div class="data-row"><span>IA:</span> <span id="data_ia" class="data-val">0</span></div>
            <div class="data-row"><span>IB:</span> <span id="data_ib" class="data-val">0</span></div>
            <div class="data-row"><span>IC:</span> <span id="data_ic" class="data-val">0</span></div>
        </div>
    </div>

    <div class="hint">ğŸ’¡ æ»¾è¼ªç¸®æ”¾ | æ‹–æ›³é ‚é» | å‹¾é¸é–é ­å›ºå®šé‚Šé•·</div>
</div>

<script>
    const canvas = document.getElementById('geoCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- State Variables ---
    let width, height;
    let viewRotation = 0; // radians
    let viewScale = 1.0;  // zoom factor
    
    let points = [
        { x: 0, y: 0, label: 'A' },
        { x: 0, y: 0, label: 'B' },
        { x: 0, y: 0, label: 'C' }
    ];
    let dragIdx = -1;
    
    // UI References
    const inputs = {
        c: document.getElementById('val_c'),
        a: document.getElementById('val_a'),
        b: document.getElementById('val_b'),
        A: document.getElementById('val_A'),
        B: document.getElementById('val_B'),
        C: document.getElementById('val_C'),
    };
    const locks = {
        c: document.getElementById('lock_c'),
        a: document.getElementById('lock_a'),
        b: document.getElementById('lock_b'),
    };
    const checkboxes = {
        G: document.getElementById('showCentroid'),
        GLines: document.getElementById('showCentroidLines'),
        O: document.getElementById('showCircum'),
        OLines: document.getElementById('showCircumLines'),
        I: document.getElementById('showIncenter'),
        ILines: document.getElementById('showIncenterLines'),
    };
    const dataDisplay = {
        area: document.getElementById('data_area'),
        peri: document.getElementById('data_peri'),
        groupG: document.getElementById('data_group_G'),
        ga: document.getElementById('data_ga'),
        gb: document.getElementById('data_gb'),
        gc: document.getElementById('data_gc'),
        groupO: document.getElementById('data_group_O'),
        R: document.getElementById('data_R'),
        groupI: document.getElementById('data_group_I'),
        r: document.getElementById('data_r'),
        ia: document.getElementById('data_ia'),
        ib: document.getElementById('data_ib'),
        ic: document.getElementById('data_ic'),
    };

    const CFG = {
        ptR: 6,
        hitR: 20,
        colors: { tri: '#34495e', G: '#e67e22', O: '#2980b9', I: '#27ae60' }
    };

    // --- Init ---
    function init() {
        resize();
        window.addEventListener('resize', resize);
        Object.values(checkboxes).forEach(cb => cb.addEventListener('change', draw));
        resetView();
    }

    function resetView() {
        viewRotation = 0;
        viewScale = 1.0;
        
        // Reset Sliders UI
        document.getElementById('rotationRange').value = 0;
        document.getElementById('rotVal').innerText = "0";
        document.getElementById('zoomRange').value = 1.0;
        document.getElementById('zoomVal').innerText = "1.0";
        
        const cx = width / 2;
        const cy = height / 2;
        points[0] = { x: cx, y: cy - 130, label: 'A' };
        points[1] = { x: cx - 130, y: cy + 100, label: 'B' };
        points[2] = { x: cx + 130, y: cy + 100, label: 'C' };
        updateUIValues();
        draw();
    }

    function resize() {
        width = canvas.parentElement.clientWidth;
        height = canvas.parentElement.clientHeight;
        canvas.width = width;
        canvas.height = height;
        draw();
    }

    // --- Math ---
    function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
    function degToRad(d) { return d * Math.PI / 180; }
    function radToDeg(r) { return r * 180 / Math.PI; }
    
    function getAngle(p1, p2, p3) {
        const d12 = dist(p1, p2);
        const d23 = dist(p2, p3);
        const d13 = dist(p1, p3);
        let val = (d12**2 + d23**2 - d13**2) / (2 * d12 * d23);
        val = Math.max(-1, Math.min(1, val)); 
        return radToDeg(Math.acos(val));
    }

    function constrainToRadius(p, center, r) {
        const d = dist(p, center);
        if (d === 0) return { x: center.x + r, y: center.y };
        const scale = r / d;
        return {
            x: center.x + (p.x - center.x) * scale,
            y: center.y + (p.y - center.y) * scale
        };
    }

    // --- Constraints ---
    function applyConstraints(movingIdx) {
        const A = points[0], B = points[1], C = points[2];
        const lock_c = locks.c.checked, lock_a = locks.a.checked, lock_b = locks.b.checked;
        const len_c = parseFloat(inputs.c.value), len_a = parseFloat(inputs.a.value), len_b = parseFloat(inputs.b.value);

        if (movingIdx === 0) { 
            if (lock_c) Object.assign(A, constrainToRadius(A, B, len_c));
            if (lock_b) Object.assign(A, constrainToRadius(A, C, len_b));
            if (lock_c && lock_b) Object.assign(A, constrainToRadius(A, B, len_c));
        } else if (movingIdx === 1) { 
            if (lock_c) Object.assign(B, constrainToRadius(B, A, len_c));
            if (lock_a) Object.assign(B, constrainToRadius(B, C, len_a));
            if (lock_c && lock_a) Object.assign(B, constrainToRadius(B, A, len_c));
        } else if (movingIdx === 2) { 
            if (lock_b) Object.assign(C, constrainToRadius(C, A, len_b));
            if (lock_a) Object.assign(C, constrainToRadius(C, B, len_a));
            if (lock_b && lock_a) Object.assign(C, constrainToRadius(C, A, len_b));
        }
    }

    function updateUIValues() {
        const d_c = dist(points[0], points[1]); 
        const d_a = dist(points[1], points[2]); 
        const d_b = dist(points[0], points[2]); 
        
        if(document.activeElement !== inputs.c) inputs.c.value = Math.round(d_c);
        if(document.activeElement !== inputs.a) inputs.a.value = Math.round(d_a);
        if(document.activeElement !== inputs.b) inputs.b.value = Math.round(d_b);

        const angA = getAngle(points[1], points[0], points[2]);
        const angB = getAngle(points[0], points[1], points[2]);
        const angC = getAngle(points[0], points[2], points[1]);

        if(document.activeElement !== inputs.A) inputs.A.value = angA.toFixed(1);
        if(document.activeElement !== inputs.B) inputs.B.value = angB.toFixed(1);
        if(document.activeElement !== inputs.C) inputs.C.value = angC.toFixed(1);
    }

    function onManualInput(type, key) {
        const val = parseFloat(inputs[key].value);
        if(isNaN(val) || val <= 0) return;
        const A = points[0], B = points[1], C = points[2];

        if (type === 'side') {
            if (key === 'c') Object.assign(B, constrainToRadius(B, A, val));
            else if (key === 'b') Object.assign(C, constrainToRadius(C, A, val));
            else if (key === 'a') Object.assign(C, constrainToRadius(C, B, val));
        } else if (type === 'angle') {
            let pivot, pFixed, pRotated;
            if (key === 'A') { pivot = A; pFixed = B; pRotated = C; }
            if (key === 'B') { pivot = B; pFixed = C; pRotated = A; }
            if (key === 'C') { pivot = C; pFixed = A; pRotated = B; }
            
            const angleFixed = Math.atan2(pFixed.y - pivot.y, pFixed.x - pivot.x);
            const distRotated = dist(pivot, pRotated);
            const cross = (pFixed.x - pivot.x)*(pRotated.y - pivot.y) - (pFixed.y - pivot.y)*(pRotated.x - pivot.x);
            const sign = cross >= 0 ? 1 : -1;
            const targetAbs = angleFixed + sign * degToRad(val);
            pRotated.x = pivot.x + distRotated * Math.cos(targetAbs);
            pRotated.y = pivot.y + distRotated * Math.sin(targetAbs);
        }
        draw();
    }

    ['c','a','b'].forEach(k => inputs[k].addEventListener('input', () => onManualInput('side', k)));
    ['A','B','C'].forEach(k => inputs[k].addEventListener('input', () => onManualInput('angle', k)));

    // --- Centers ---
    function getCentroid(A, B, C) {
        return { x: (A.x+B.x+C.x)/3, y: (A.y+B.y+C.y)/3 };
    }
    function getIncenter(A, B, C) {
        const a = dist(B, C), b = dist(A, C), c = dist(A, B);
        const p = a + b + c;
        return { x: (a*A.x+b*B.x+c*C.x)/p, y: (a*A.y+b*B.y+c*C.y)/p, r: Math.sqrt(p/2*(p/2-a)*(p/2-b)*(p/2-c))/(p/2) };
    }
    function getCircumcenter(A, B, C) {
        const D = 2*(A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y));
        if(Math.abs(D) < 1e-6) return null;
        const Ux = ((A.x**2+A.y**2)*(B.y-C.y) + (B.x**2+B.y**2)*(C.y-A.y) + (C.x**2+C.y**2)*(A.y-B.y))/D;
        const Uy = ((A.x**2+A.y**2)*(C.x-B.x) + (B.x**2+B.y**2)*(A.x-C.x) + (C.x**2+C.y**2)*(B.x-A.x))/D;
        return { x: Ux, y: Uy, r: dist({x:Ux,y:Uy}, A) };
    }

    // --- Update Data ---
    function updateRealTimeData(A, B, C) {
        const c = dist(A, B), a = dist(B, C), b = dist(A, C);
        const s = (a + b + c) / 2;
        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        
        dataDisplay.area.innerText = area.toFixed(1);
        dataDisplay.peri.innerText = (a+b+c).toFixed(1);

        if (checkboxes.G.checked) {
            dataDisplay.groupG.style.display = 'block';
            const G = getCentroid(A, B, C);
            dataDisplay.ga.innerText = dist(G, A).toFixed(1);
            dataDisplay.gb.innerText = dist(G, B).toFixed(1);
            dataDisplay.gc.innerText = dist(G, C).toFixed(1);
        } else {
            dataDisplay.groupG.style.display = 'none';
        }

        if (checkboxes.O.checked) {
            dataDisplay.groupO.style.display = 'block';
            const O = getCircumcenter(A, B, C);
            if(O) dataDisplay.R.innerText = O.r.toFixed(1);
        } else {
            dataDisplay.groupO.style.display = 'none';
        }

        if (checkboxes.I.checked) {
            dataDisplay.groupI.style.display = 'block';
            const I = getIncenter(A, B, C);
            dataDisplay.r.innerText = I.r.toFixed(1);
            dataDisplay.ia.innerText = dist(I, A).toFixed(1);
            dataDisplay.ib.innerText = dist(I, B).toFixed(1);
            dataDisplay.ic.innerText = dist(I, C).toFixed(1);
        } else {
            dataDisplay.groupI.style.display = 'none';
        }
    }

    // --- Drawing ---
    function drawPoint(p, color, label) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, CFG.ptR / viewScale, 0, Math.PI*2); // Adjust point size by scale
        ctx.fillStyle = color; ctx.fill();
        ctx.strokeStyle = 'white'; ctx.lineWidth=2/viewScale; ctx.stroke();
        
        ctx.fillStyle = '#333'; 
        ctx.font = `bold ${14/viewScale}px Arial`; // Adjust font size
        ctx.fillText(label, p.x + 10/viewScale, p.y - 10/viewScale);
    }
    
    function drawLine(p1, p2, color, dashed=false, width=1) {
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = color; ctx.lineWidth = width / viewScale; // Adjust line width
        if(dashed) ctx.setLineDash([5/viewScale, 5/viewScale]); else ctx.setLineDash([]);
        ctx.stroke(); ctx.setLineDash([]);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        ctx.save();
        const cx = width/2, cy = height/2;
        ctx.translate(cx, cy);
        ctx.scale(viewScale, viewScale); // Apply Zoom
        ctx.rotate(viewRotation);        // Apply Rotation
        ctx.translate(-cx, -cy);

        // Grid
        ctx.strokeStyle = 'rgba(0,0,0,0.05)';
        ctx.lineWidth = 1/viewScale;
        ctx.beginPath();
        // Draw a larger grid area to cover zoom out
        const gridLimit = Math.max(width, height) * 2 / viewScale; 
        for(let i=-gridLimit; i<gridLimit*2; i+=50) { ctx.moveTo(i, -gridLimit); ctx.lineTo(i, gridLimit*2); }
        ctx.stroke();

        const [A, B, C] = points;

        // Triangle
        ctx.beginPath();
        ctx.moveTo(A.x, A.y); ctx.lineTo(B.x, B.y); ctx.lineTo(C.x, C.y); ctx.closePath();
        ctx.strokeStyle = CFG.colors.tri; ctx.lineWidth = 3/viewScale; ctx.stroke();
        ctx.fillStyle = "rgba(52, 73, 94, 0.05)"; ctx.fill();

        // 1. Centroid (G)
        if(checkboxes.G.checked) {
            const G = getCentroid(A, B, C);
            drawLine(A, {x:(B.x+C.x)/2, y:(B.y+C.y)/2}, CFG.colors.G, true);
            drawLine(B, {x:(A.x+C.x)/2, y:(A.y+C.y)/2}, CFG.colors.G, true);
            drawLine(C, {x:(A.x+B.x)/2, y:(A.y+B.y)/2}, CFG.colors.G, true);
            
            if(checkboxes.GLines.checked) {
                ctx.globalAlpha = 0.8;
                drawLine(G, A, CFG.colors.G, false, 2);
                drawLine(G, B, CFG.colors.G, false, 2);
                drawLine(G, C, CFG.colors.G, false, 2);
                ctx.globalAlpha = 1.0;
            }
            drawPoint(G, CFG.colors.G, 'G');
        }

        // 2. Circumcenter (O)
        if(checkboxes.O.checked) {
            const O = getCircumcenter(A, B, C);
            if(O) {
                ctx.beginPath(); ctx.arc(O.x, O.y, O.r, 0, Math.PI*2);
                ctx.strokeStyle = CFG.colors.O; ctx.lineWidth=1/viewScale; ctx.stroke();
                
                if(checkboxes.OLines.checked) {
                    ctx.globalAlpha = 0.6;
                    drawLine(O, A, CFG.colors.O, false, 2);
                    drawLine(O, B, CFG.colors.O, false, 2);
                    drawLine(O, C, CFG.colors.O, false, 2);
                    ctx.globalAlpha = 1.0;
                }
                drawPoint(O, CFG.colors.O, 'O');
            }
        }

        // 3. Incenter (I)
        if(checkboxes.I.checked) {
            const I = getIncenter(A, B, C);
            ctx.beginPath(); ctx.arc(I.x, I.y, I.r, 0, Math.PI*2);
            ctx.strokeStyle = CFG.colors.I; ctx.lineWidth=1/viewScale; ctx.stroke();

            ctx.globalAlpha = 0.3;
            drawLine(A, I, CFG.colors.I, true); 
            drawLine(B, I, CFG.colors.I, true);
            drawLine(C, I, CFG.colors.I, true);
            ctx.globalAlpha = 1.0;

            if(checkboxes.ILines.checked) {
                ctx.globalAlpha = 0.8;
                drawLine(I, A, CFG.colors.I, false, 2);
                drawLine(I, B, CFG.colors.I, false, 2);
                drawLine(I, C, CFG.colors.I, false, 2);
                ctx.globalAlpha = 1.0;
            }
            drawPoint(I, CFG.colors.I, 'I');
        }

        // Vertices
        points.forEach(p => drawPoint(p, CFG.colors.tri, p.label));

        ctx.restore(); 
        
        updateRealTimeData(A, B, C);
    }

    // --- Interaction ---
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const mx = evt.clientX - rect.left;
        const my = evt.clientY - rect.top;

        // Inverse Transform Logic
        const cx = width/2, cy = height/2;
        
        // 1. Translate to center
        let tx = mx - cx;
        let ty = my - cy;

        // 2. Inverse Scale (New!)
        tx /= viewScale;
        ty /= viewScale;

        // 3. Inverse Rotate
        const cos = Math.cos(-viewRotation);
        const sin = Math.sin(-viewRotation);
        let rx = tx * cos - ty * sin;
        let ry = tx * sin + ty * cos;

        // 4. Translate back
        return { x: rx + cx, y: ry + cy };
    }

    // Zoom Slider Listener
    const zoomSlider = document.getElementById('zoomRange');
    zoomSlider.addEventListener('input', (e) => {
        viewScale = parseFloat(e.target.value);
        document.getElementById('zoomVal').innerText = viewScale.toFixed(1);
        draw();
    });

    // Rotation Slider Listener
    const rotSlider = document.getElementById('rotationRange');
    rotSlider.addEventListener('input', (e) => {
        viewRotation = degToRad(parseInt(e.target.value));
        document.getElementById('rotVal').innerText = e.target.value;
        draw();
    });

    // Mouse Wheel Zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -Math.sign(e.deltaY) * 0.1;
        let newScale = viewScale + delta;
        newScale = Math.max(0.5, Math.min(3.0, newScale)); // Clamp
        
        viewScale = newScale;
        zoomSlider.value = viewScale;
        document.getElementById('zoomVal').innerText = viewScale.toFixed(1);
        draw();
    }, {passive: false});

    // Mouse Dragging
    canvas.addEventListener('mousedown', e => {
        const m = getMousePos(e);
        // Adjust hit radius based on zoom so it's easier to grab when zoomed out
        const effectiveHitR = CFG.hitR / viewScale; 
        points.forEach((p, i) => { if(dist(m, p) < effectiveHitR) dragIdx = i; });
    });
    
    canvas.addEventListener('mousemove', e => {
        const m = getMousePos(e);
        let hovering = false;
        const effectiveHitR = CFG.hitR / viewScale;
        points.forEach(p => { if(dist(m, p) < effectiveHitR) hovering = true; });
        canvas.style.cursor = hovering ? 'pointer' : 'default';

        if(dragIdx !== -1) {
            points[dragIdx].x = m.x;
            points[dragIdx].y = m.y;
            applyConstraints(dragIdx);
            updateUIValues();
            draw();
        }
    });

    window.addEventListener('mouseup', () => dragIdx = -1);

    // Touch Support
    canvas.addEventListener('touchstart', e => {
        const m = getMousePos(e.touches[0]);
        const effectiveHitR = CFG.hitR / viewScale;
        points.forEach((p, i) => { if(dist(m, p) < effectiveHitR) dragIdx = i; });
        if(dragIdx!==-1) e.preventDefault();
    }, {passive:false});

    canvas.addEventListener('touchmove', e => {
        if(dragIdx!==-1) {
            e.preventDefault();
            const m = getMousePos(e.touches[0]);
            points[dragIdx].x = m.x; points[dragIdx].y = m.y;
            applyConstraints(dragIdx);
            updateUIValues();
            draw();
        }
    }, {passive:false});

    init();
</script>
</body>
</html>